#'   write_csv = TRUE,
#'   file = "proteomics_single_exposure_results.csv"
#' )
#' }
#'
#' @export
#' @importFrom stats lm confint p.adjust complete.cases
#' @importFrom utils write.csv
lm_protein <- function(
df,
outcomes,
main_exposures,
covariates = character(0),
p_adjust_method = "BH",
write_csv = FALSE,
file = "proteomics_single_exposure_results.csv") {
## check
stopifnot(is.data.frame(df))
stopifnot(is.character(outcomes), length(outcomes) >= 1)
stopifnot(is.character(main_exposures), length(main_exposures) >= 1)
stopifnot(is.character(covariates))
miss_out <- setdiff(outcomes, colnames(df))
miss_exp <- setdiff(main_exposures, colnames(df))
miss_cov <- setdiff(covariates, colnames(df))
if (length(miss_out)) stop("Outcome columns not found in df: ", paste(miss_out, collapse = ", "))
if (length(miss_exp)) stop("Exposure columns not found in df: ", paste(miss_exp, collapse = ", "))
if (length(miss_cov)) stop("Covariate columns not found in df: ", paste(miss_cov, collapse = ", "))
# helper to extract coefficient for a single exposure term
.extract_row <- function(fit, exposure, outcome_name, n_obs) {
sm <- summary(fit)
coef <- sm$coefficients
r2 <- unname(sm$r.squared)
ar2 <- unname(sm$adj.r.squared)
get_ci <- function(term) {
ci <- tryCatch(confint(fit, parm = term, level = 0.95),
error = function(e) c(NA_real_, NA_real_))
if (is.matrix(ci)) c(ci[1, 1], ci[1, 2]) else ci
}
if (!exposure %in% rownames(coef)) {
data.frame(
exposure  = exposure,
outcome   = outcome_name,
n         = n_obs,
estimate  = NA_real_,
std.error = NA_real_,
statistic = NA_real_,
p.value   = NA_real_,
conf.low  = NA_real_,
conf.high = NA_real_,
r.squared = r2,
adj.r.squared = ar2,
stringsAsFactors = FALSE
)
} else {
ci <- get_ci(exposure)
data.frame(
exposure  = exposure,
outcome   = outcome_name,
n         = n_obs,
estimate  = unname(coef[exposure, "Estimate"]),
std.error = unname(coef[exposure, "Std. Error"]),
statistic = unname(coef[exposure, "t value"]),
p.value   = unname(coef[exposure, "Pr(>|t|)"]),
conf.low  = ci[1],
conf.high = ci[2],
r.squared = r2,
adj.r.squared = ar2,
stringsAsFactors = FALSE
)
}
}
results <- list()
idx_res <- 0L
# loop over exposures; for each exposure, fit across all outcomes
for (e in main_exposures) {
for (y in outcomes) {
cols <- c(y, e, covariates)
sub  <- df[, cols, drop = FALSE]
sub  <- sub[stats::complete.cases(sub), , drop = FALSE]
n_obs <- nrow(sub)
# minimal df check (still allow fit, but warn if very small)
if (n_obs < (2 + length(covariates))) {
warning("Outcome ", y, ", exposure ", e, ": small sample size relative to predictors (n = ", n_obs, ").")
}
# build formula: y ~ e + covariates
rhs <- if (length(covariates) > 0) {
paste(c(e, covariates), collapse = " + ")
} else {
e
}
fml <- as.formula(paste(y, "~", rhs))
fit <- tryCatch(stats::lm(fml, data = sub), error = function(err) NULL)
idx_res <- idx_res + 1L
if (is.null(fit)) {
results[[idx_res]] <- data.frame(
exposure  = e, outcome = y, n = n_obs,
estimate  = NA_real_, std.error = NA_real_, statistic = NA_real_, p.value = NA_real_,
conf.low  = NA_real_, conf.high = NA_real_,
r.squared = NA_real_, adj.r.squared = NA_real_,
stringsAsFactors = FALSE
)
} else {
results[[idx_res]] <- .extract_row(fit, exposure = e, outcome_name = y, n_obs = n_obs)
}
}
}
out <- do.call(rbind, results)
# ---- per-exposure BH adjustment across outcomes ----
out$q_value <- NA_real_
for (e in unique(out$exposure)) {
ix <- which(out$exposure == e)
out$q_value[ix] <- stats::p.adjust(out$p.value[ix], method = p_adjust_method)
}
# nice ordering
out <- out[order(out$exposure, out$outcome), ]
if (isTRUE(write_csv)) {
utils::write.csv(out, file = file, row.names = FALSE)
}
return(out)
}
# ---- Generate synthetic proteomics data ----
n <- 300  # number of participants
p_protein <- 10  # number of protein outcomes
# outcomes: simulated protein expression (continuous)
protein_data <- as.data.frame(
replicate(p_protein, rnorm(n, mean = 10, sd = 2))
)
colnames(protein_data) <- paste0("protein_", 1:p_protein)
# exposures: e.g. air pollutants
exposure_data <- data.frame(
NO2 = rnorm(n, mean = 20, sd = 5),
PM25 = rnorm(n, mean = 35, sd = 8)
)
# covariates: demographics / lifestyle
covariate_data <- data.frame(
age = runif(n, 40, 80),
sex = sample(c(0, 1), n, replace = TRUE), # 0 = female, 1 = male
BMI = rnorm(n, 24, 3),
smoking = sample(c(0, 1), n, replace = TRUE)
)
# combine into one dataset
mydata <- cbind(protein_data, exposure_data, covariate_data)
# inspect
str(mydata)
head(mydata[, 1:8])
# Example usage of lm_protein
res <- lm_protein(
df = mydata,
outcomes = paste0("protein_", 1:p_protein),
main_exposures = c("NO2", "PM25"),
covariates = c("age", "sex", "BMI", "smoking"),
write_csv = TRUE,
file = "proteomics_single_exposure_results.csv"
)
res
getwd()
a <- readRDS("./Desktop/ukb/ukb空气污染物/combine/5prodata_final.rds")
a1 <- a[[1]]
summary(a1$insulin)
table(a1$insulin)
View(a1)
table(a1$antihypertensive)
b <- readRDS("./Desktop/ukb/ukb空气污染物/data_complete10301521.rds")
table(b$insulin)
grepl("3", 123)
grepl("3", "123")
rm(list = ls())
getwd()
a <- readRDS("/Users/hinna/Desktop/work/lyx/cohort_final.rds")
View(a)
len(unique(a$`Participant ID`))
length(unique(a$`Participant ID`))
dup_rows <- a[duplicated(a), ]
View(dup_rows)
View(dup_rows)
b <- a[a$`Participant ID` == 5110403, ]
View(b)
library(TCMDATA)
data("demo_ppi")
ppi <- compute_nodeinfo(demo_ppi)
rk <- rank_ppi_nodes(ppi)
View(rk)
ppi <- rk[[1]]
rk_res <- rk[[2]]
View(rk_res)
head(rk_Res)
head(rk_res)
library(ggplot2)
library(ComplexHeatmap)
library(circlize)
rownames(rk_res) <- rk_res$name
mat_data <- rk_res[, -1]
View(mat_data)
## exclude factor cols and score col
mat_data <- mat_data[, !c(12, 20, 21)]
View(mat_data)
## exclude factor cols and score col
remove_cols <- c(12, 20, 21)
mat_data <- mat_data[, !colnames(remove_cols) %in% remove_cols]
mat_data <- rk_res[, -1]
## exclude factor cols and score col
remove_cols <- c(12, 20, 21)
mat_data <- mat_data[, !colnames(remove_cols) %in% remove_cols]
mat_data <- rk_res[, -1]
## exclude factor cols and score col
remove_cols <- c(12, 20, 21)
mat_data <- mat_data[, !colnames(mat_data) %in% remove_cols]
View(mat_data)
mat_data <- rk_res[, -1]
## exclude factor cols and score col
remove_cols <- colnames(mat_data)[c(12, 20, 21)]
mat_data <- mat_data[, !colnames(mat_data) %in% remove_cols]
View(mat_data)
## scale
mat_scaled <- scale(mat_data)
View(mat_scaled)
mat_scaled[is.na(mat_scaled)] <- 0
col_fun = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B"))
# 创建热图对象
ht <- Heatmap(mat_scaled,
name = "Z-score",       # 图例标题
col = col_fun,          # 使用上面定义的颜色
# --- 聚类设置 ---
cluster_rows = TRUE,    # 【关键】对蛋白（行）聚类
cluster_columns = FALSE,# 【关键】不对指标（列）聚类
# --- 外观美化 ---
rect_gp = gpar(col = "white", lwd = 1), # 每个格子加白色边框，看起来更精致
row_names_gp = gpar(fontsize = 12, fontface = "bold"), # 行名加粗
column_names_gp = gpar(fontsize = 10, fontface = "italic"), # 列名斜体，更有学术感
column_names_rot = 45,  # 列名旋转 45 度
# --- 树状图设置 ---
row_dend_width = unit(2, "cm"), # 左侧聚类树的宽度
# --- 这里的列顺序将保持您数据框原本的顺序 ---
# 如果您想指定列的顺序，可以在这里加 column_order 参数
# column_order = c("degree", "MCC", "MNC", ...)
)
ht
colnames(mat_data)
colnames(rk_res)
# select neccessary cols for inputs
colnames(mat_data)
library(dplyr)
# select neccessary cols for inputs
colnames(mat_data)
mat_data <- mat_data %>%
select(c(1, 2, 3, 5, 9, 12, 13, 14, 17, 18))
## scale
mat_scaled <- scale(mat_data)
mat_scaled[is.na(mat_scaled)] <- 0
col_fun = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B"))
# 创建热图对象
ht <- Heatmap(mat_scaled,
name = "Z-score",       # 图例标题
col = col_fun,          # 使用上面定义的颜色
# --- 聚类设置 ---
cluster_rows = TRUE,
cluster_columns = FALSE,
# --- 外观美化 ---
rect_gp = gpar(col = "white", lwd = 1), # 每个格子加白色边框，看起来更精致
row_names_gp = gpar(fontsize = 12, fontface = "bold"), # 行名加粗
column_names_gp = gpar(fontsize = 10, fontface = "italic"), # 列名斜体，更有学术感
column_names_rot = 45,  # 列名旋转 45 度
# --- 树状图设置 ---
row_dend_width = unit(2, "cm"), # 左侧聚类树的宽度
# --- 这里的列顺序将保持您数据框原本的顺序 ---
# 如果您想指定列的顺序，可以在这里加 column_order 参数
# column_order = c("degree", "MCC", "MNC", ...)
)
ht
# 创建热图对象
ht <- Heatmap(mat_scaled,
name = "Z-score",       # 图例标题
col = col_fun,          # 使用上面定义的颜色
# --- 聚类设置 ---
cluster_rows = TRUE,
cluster_columns = FALSE,
# --- 外观美化 ---
rect_gp = gpar(col = "white", lwd = 1), # 每个格子加白色边框，看起来更精致
row_names_gp = gpar(fontsize = 12), # 行名加粗
column_names_gp = gpar(fontsize = 10, fontface = "italic"), # 列名斜体，更有学术感
column_names_rot = 45,  # 列名旋转 45 度
# --- 树状图设置 ---
row_dend_width = unit(2, "cm"), # 左侧聚类树的宽度
# --- 这里的列顺序将保持您数据框原本的顺序 ---
# 如果您想指定列的顺序，可以在这里加 column_order 参数
# column_order = c("degree", "MCC", "MNC", ...)
)
ht
View(rk_res)
# select neccessary cols for inputs
colnames(mat_data)
mat_data <- rk_res[, -1]
## exclude factor cols and score col
remove_cols <- colnames(mat_data)[c(12, 20, 21)]
mat_data <- mat_data[, !colnames(mat_data) %in% remove_cols]
# select neccessary cols for inputs
colnames(mat_data)
mat_data <- mat_data %>%
select(c(1, 2, 3, 5, 8, 9, 12, 13, 14, 16, 17))
## scale
mat_scaled <- scale(mat_data)
mat_scaled[is.na(mat_scaled)] <- 0
col_fun = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B"))
# 创建热图对象
ht <- Heatmap(mat_scaled,
name = "Z-score",       # 图例标题
col = col_fun,          # 使用上面定义的颜色
# --- 聚类设置 ---
cluster_rows = TRUE,
cluster_columns = FALSE,
# --- 外观美化 ---
rect_gp = gpar(col = "white", lwd = 1), # 每个格子加白色边框，看起来更精致
row_names_gp = gpar(fontsize = 12), # 行名加粗
column_names_gp = gpar(fontsize = 10, fontface = "italic"), # 列名斜体，更有学术感
column_names_rot = 45,  # 列名旋转 45 度
# --- 树状图设置 ---
row_dend_width = unit(2, "cm"), # 左侧聚类树的宽度
# --- 这里的列顺序将保持您数据框原本的顺序 ---
# 如果您想指定列的顺序，可以在这里加 column_order 参数
# column_order = c("degree", "MCC", "MNC", ...)
)
ht
rep(1, nrow(rk_res))
paste("name", rep(1, nrow(data)))
paste("name", rep(1, nrow(rk_res)))
paste("node", rep(1:nrow(rk_res), nrow(rk_res)))
paste("node", rep(1:nrow(rk_res)))
#' @param id_col Character. The column name serving as row names. Default is "name".
#' @param select_cols Character Vector. The specific columns to include in the heatmap. Default all columns except `id_col` are used.
#' @param colors Vector of length 3. Colors for low (-2), zero (0), and high (2) values. Default is c("#2166AC", "white", "#B2182B").
#' @param cluster_rows Logical. Whether to perform hierarchical clustering on rows. Default is TRUE.
#' @param cluster_cols Logical. Whether to perform hierarchical clustering on columns. Default is FALSE.
#' @param ... Additional arguments passed to `ComplexHeatmap::Heatmap` (e.g., column_title, show_row_names).
#' @importFrom circlize colorRamp2
#' @importFrom ComplexHeatmap Heatmap
#' @return A Heatmap object.
#' @export
plot_topo_heatmap <- function(data,
id_col = "name",
select_cols = NULL,
colors = c("#2166AC", "white", "#B2182B"),
cluster_rows = TRUE,
cluster_cols = FALSE,
...) {
if (!id_col %in% colnames(data)) {
stop(paste("Error: The column", id_col, "does not exist in the input data."))
}
plot_data <- data
rownames(plot_data) <- plot_data[[id_col]]
plot_data[[id_col]] <- NULL
if (!is.null(select_cols)) {
missing <- setdiff(select_cols, colnames(plot_data))
if (length(missing) > 0) {
stop(paste("Error: The following columns were not found:", paste(missing, collapse=", ")))
}
plot_data <- plot_data[, select_cols, drop = FALSE]
}
is_num <- sapply(plot_data, is.numeric)
plot_data <- plot_data[, is_num, drop = FALSE]
if (ncol(plot_data) == 0) {
stop("Error: No numeric columns left to plot after selection.")
}
# scale data and deal with NA
mat_scaled <- scale(plot_data)
mat_scaled[is.na(mat_scaled)] <- 0
# Color Mapping
col_fun <- circlize::colorRamp2(c(-2, 0, 2), colors)
p <- ComplexHeatmap::Heatmap(matrix = mat_scaled,
name = "Z-score",
col = col_fun,
cluster_rows = cluster_rows,
cluster_columns = cluster_cols,
rect_gp = gpar(col = "white", lwd = 1),
row_names_gp = gpar(fontsize = 12),
column_names_gp = gpar(fontsize = 10, fontface = "italic"),
column_names_rot = 45,
row_dend_width = unit(2, "cm"),
...)
return(p)
}
p1 <- PlotNodeHeatmap(rk_res)
#' @param id_col Character. The column name serving as row names. Default is "name".
#' @param select_cols Character Vector. The specific columns to include in the heatmap. Default all columns except `id_col` are used.
#' @param colors Vector of length 3. Colors for low (-2), zero (0), and high (2) values. Default is c("#2166AC", "white", "#B2182B").
#' @param cluster_rows Logical. Whether to perform hierarchical clustering on rows. Default is TRUE.
#' @param cluster_cols Logical. Whether to perform hierarchical clustering on columns. Default is FALSE.
#' @param ... Additional arguments passed to `ComplexHeatmap::Heatmap` (e.g., column_title, show_row_names).
#' @importFrom circlize colorRamp2
#' @importFrom ComplexHeatmap Heatmap
#' @return A Heatmap object.
#' @export
PlotNodeHeatmap <- function(data,
id_col = "name",
select_cols = NULL,
colors = c("#2166AC", "white", "#B2182B"),
cluster_rows = TRUE,
cluster_cols = FALSE,
...) {
if (!id_col %in% colnames(data)) {
stop(paste("Error: The column", id_col, "does not exist in the input data."))
}
plot_data <- data
rownames(plot_data) <- plot_data[[id_col]]
plot_data[[id_col]] <- NULL
if (!is.null(select_cols)) {
missing <- setdiff(select_cols, colnames(plot_data))
if (length(missing) > 0) {
stop(paste("Error: The following columns were not found:", paste(missing, collapse=", ")))
}
plot_data <- plot_data[, select_cols, drop = FALSE]
}
is_num <- sapply(plot_data, is.numeric)
plot_data <- plot_data[, is_num, drop = FALSE]
if (ncol(plot_data) == 0) {
stop("Error: No numeric columns left to plot after selection.")
}
# scale data and deal with NA
mat_scaled <- scale(plot_data)
mat_scaled[is.na(mat_scaled)] <- 0
# Color Mapping
col_fun <- circlize::colorRamp2(c(-2, 0, 2), colors)
p <- ComplexHeatmap::Heatmap(matrix = mat_scaled,
name = "Z-score",
col = col_fun,
cluster_rows = cluster_rows,
cluster_columns = cluster_cols,
rect_gp = gpar(col = "white", lwd = 1),
row_names_gp = gpar(fontsize = 12),
column_names_gp = gpar(fontsize = 10, fontface = "italic"),
column_names_rot = 45,
row_dend_width = unit(2, "cm"),
...)
return(p)
}
p1 <- PlotNodeHeatmap(rk_res)
p1
selected_cols <- colnames(rk_res)[c(1, 2, 3, 5, 8, 9, 12, 13, 14, 16, 17)]
p1 <- PlotNodeHeatmap(rk_res, select_cols = selected_cols)
selected_cols <- colnames(rk_res)[c(2, 3, 5, 8, 9, 12, 13, 14, 16, 17)]
p1 <- PlotNodeHeatmap(rk_res, select_cols = selected_cols)
p1
colnames(rk_res)
selected_cols <- colnames(rk_res)[c(2, 3, 4, 6, 9, 12, 14, 15, 16)]
p1 <- PlotNodeHeatmap(rk_res, select_cols = selected_cols)
p1
rm(list = ls())
#' @importFrom grid gpar unit
#' @return A Heatmap object.
#' @examples
#' data(demo_ppi)
#' ppi <- compute_nodeinfo(demo_ppi)
#' rk_res <- rank_ppi_nodes(ppi)[[2]]
#' selected_cols <- colnames(rk_res)[c(2, 3, 4, 6, 9, 12, 14, 15, 16)]
#' p1 <- PlotNodeHeatmap(rk_res, select_cols = selected_cols)
#' print(p1)
#' @export
PlotNodeHeatmap <- function(data,
id_col = "name",
select_cols = NULL,
colors = c("#2166AC", "white", "#B2182B"),
cluster_rows = TRUE,
cluster_cols = FALSE,
...) {
if (!id_col %in% colnames(data)) {
stop(paste("Error: The column", id_col, "does not exist in the input data."))
}
plot_data <- data
rownames(plot_data) <- plot_data[[id_col]]
plot_data[[id_col]] <- NULL
if (!is.null(select_cols)) {
missing <- setdiff(select_cols, colnames(plot_data))
if (length(missing) > 0) {
stop(paste("Error: The following columns were not found:", paste(missing, collapse=", ")))
}
plot_data <- plot_data[, select_cols, drop = FALSE]
}
is_num <- sapply(plot_data, is.numeric)
plot_data <- plot_data[, is_num, drop = FALSE]
if (ncol(plot_data) == 0) {
stop("Error: No numeric columns left to plot after selection.")
}
# scale data and deal with NA
mat_scaled <- scale(plot_data)
mat_scaled[is.na(mat_scaled)] <- 0
# Color Mapping
col_fun <- circlize::colorRamp2(c(-2, 0, 2), colors)
p <- ComplexHeatmap::Heatmap(matrix = mat_scaled,
name = "Z-score",
col = col_fun,
cluster_rows = cluster_rows,
cluster_columns = cluster_cols,
rect_gp = gpar(col = "white", lwd = 1),
row_names_gp = gpar(fontsize = 12),
column_names_gp = gpar(fontsize = 10, fontface = "italic"),
column_names_rot = 45,
row_dend_width = unit(2, "cm"),
...)
return(p)
}
data(demo_ppi)
ppi <- compute_nodeinfo(demo_ppi)
rk_res <- rank_ppi_nodes(ppi)[[2]]
selected_cols <- colnames(rk_res)[c(2, 3, 4, 6, 9, 12, 14, 15, 16)]
p1 <- PlotNodeHeatmap(rk_res, select_cols = selected_cols)
print(p1)
#' add a demo igraph object for PPI analysis
dir <- "/Users/hinna/Desktop/yulab/casestudy/demo_ppi.rds"
demo_ppi <- readRDS(dir)
usethis::use_data(demo_ppi, overwrite = TRUE)
getwd()
setwd("/Users/hinna/TCMDATA")
usethis::use_data(demo_ppi, overwrite = TRUE)
